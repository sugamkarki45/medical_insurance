The Postman collection you provided for the IMIS legacy test server (`IMIS LEGACY (INSURANCE TEST SERVER).postman_collection.json`) contains several endpoints that interact with Nepal's Health Insurance Board (HIB) system, built on openIMIS using FHIR R4 standards. These endpoints allow your insurance API to fetch critical information for processing claims, such as patient details, coverage eligibility, and claim statuses, which are essential for aligning your `ClaimInput` model with IMIS requirements and ensuring accurate claim submissions. Below, I’ll detail each endpoint, the information it provides, and the reasons why it’s valuable for your workflow, including how it relates to calculating claimable amounts and handling `remaining_balance`.


### Endpoints and Their Information
The collection includes five endpoints. I’ll analyze each, explain what data you get, and why it’s useful for your insurance system, which pre-calculates claimable amounts using a JSON rules file, submits claims to IMIS, and returns results to external systems (e.g., EHR).

#### 1. **Patient Info**
- **Endpoint**: `GET http://imislegacy.hib.gov.np/api/api_fhir/Patient/?identifier={identifier}`
- **Method**: GET
- **Auth**: Basic (username: `hib_testuser_testfhir`, password: `f/\N6k@67`) + `remote-user` header
- **Query Parameter**: `identifier` (e.g., `740500036`, likely a patient ID or insurance number)
- **Information Provided**:
  - Returns a FHIR `Patient` resource bundle with details about the patient matching the provided `identifier`.
  - Key fields:
    - `id`: Patient UUID (e.g., `C335B6A2-738C-4373-AFF4-DAD1B8B09645`), used in other endpoints like `EligibilityRequest` and `Claim`.
    - `identifier`: List of identifiers (e.g., insurance number, MRN).
    - `name`, `birthDate`, `gender`, etc. (if available in IMIS).
  - Example response (simplified):
    ```json
    {
      "resourceType": "Bundle",
      "entry": [
        {
          "resource": {
            "resourceType": "Patient",
            "id": "C335B6A2-738C-4373-AFF4-DAD1B8B09645",
            "identifier": [
              {"system": "http://openimis.org", "value": "740500036"}
            ],
            "name": [{"family": "Doe", "given": ["John"]}],
            "birthDate": "1980-01-01"
          }
        }
      ]
    }
    ```
- **Reasons for Use**:
  - **Resolve Patient UUID**: Your `ClaimInput.patient_id` (e.g., a string like "740500036") must be converted to a FHIR `Patient/{uuid}` reference for `EligibilityRequest` and `Claim` submissions. This endpoint maps your `patient_id` to the IMIS UUID.
  - **Validation**: Ensures the patient exists in IMIS before processing claims, preventing rejections due to invalid `patient_id`.
  - **Enrich Data**: If your EHR provides minimal patient data, you can fetch additional details (e.g., `birthDate` to validate `patient_age`) for local rules or compliance.
  - **Workflow Fit**: Critical first step before calling `EligibilityRequest` or submitting a `Claim`, as both require `Patient/{uuid}`.
- **Why It Matters for Your System**: Without the UUID, you can’t query eligibility or submit claims. This endpoint bridges your `ClaimInput` to IMIS’s FHIR structure, ensuring compatibility.

#### 2. **Eligibility Request**
- **Endpoint**: `POST http://imislegacy.hib.gov.np/api/api_fhir/EligibilityRequest/`
- **Method**: POST
- **Auth**: Same as above
- **Body**: FHIR `EligibilityRequest` JSON
  ```json
  {
    "resourceType": "EligibilityRequest",
    "patient": {"reference": "Patient/{uuid}"}
  }
  ```
- **Information Provided**:
  - Returns a FHIR `CoverageEligibilityResponse` with the patient’s insurance coverage details.
  - Key fields:
    - `insurance[].benefitBalance`: List of coverage categories (e.g., "hospital", "non-hospital") with:
      - `allowedMoney.value`: Remaining balance (e.g., NPR 50,000 for hospital claims).
      - `usedMoney.value`: Amount already claimed (optional, if provided by IMIS).
    - `outcome`: Status of the request (e.g., "complete" or "error").
    - `error`: Any issues (e.g., patient not covered).
  - Example response (simplified):
    ```json
    {
      "resourceType": "CoverageEligibilityResponse",
      "status": "active",
      "patient": {"reference": "Patient/740500036"},
      "insurance": [
        {
          "coverage": {"reference": "Coverage/12345"},
          "benefitBalance": [
            {
              "category": {"coding": [{"code": "hospital"}]},
              "allowedMoney": {"value": 50000.0, "currency": "NPR"}
            },
            {
              "category": {"coding": [{"code": "non-hospital"}]},
              "allowedMoney": {"value": 25000.0, "currency": "NPR"}
            }
          ]
        }
      ],
      "outcome": "complete"
    }
    ```
- **Reasons for Use**:
  - **Fetch `remaining_balance`**: Directly provides the patient’s remaining coverage (e.g., NPR 50,000 for IPD), which you can use in `ClaimProcessor.calculate_claim` to cap `total_claimable`. Critical if `ClaimInput.remaining_balance` is `None` or outdated.
  - **Validate Coverage**: Confirms the patient is insured and eligible for claims, reducing IMIS rejections (e.g., for expired policies or waiting periods).
  - **Category-Specific Balances**: HIB guidelines (per your JSON rules, Chapter 5) split coverage (e.g., hospital vs. non-hospital). This endpoint lets you select the right balance based on `service_type` (OPD/ER/IPD).
  - **Workflow Fit**: Enhances your pre-calculation by providing real-time balance data, making local estimates more accurate before `Claim` submission.
- **Why It Matters for Your System**: Your workflow relies on accurate `remaining_balance` to avoid overestimating claimable amounts. This endpoint ensures your local calculations align with IMIS’s adjudication, reducing discrepancies.

#### 3. **Get All Claims**
- **Endpoint**: `GET http://imislegacy.hib.gov.np/api/api_fhir/Claim/`
- **Method**: GET
- **Auth**: Same as above
- **Information Provided**:
  - Returns a FHIR `Bundle` of all `Claim` resources submitted to IMIS (likely filtered by your account’s permissions, e.g., claims from your hospital).
  - Key fields per `Claim`:
    - `id`: Claim UUID.
    - `patient.reference`: Patient UUID.
    - `total.value`: Billed amount.
    - `item[]`: Claimed services/medicines.
    - `status`: Claim status (e.g., "active", "cancelled").
  - Example response:
    ```json
    {
      "resourceType": "Bundle",
      "entry": [
        {
          "resource": {
            "resourceType": "Claim",
            "id": "2DDE79F9-AD6D-4821-843D-9396C78BD8FB",
            "status": "active",
            "patient": {"reference": "Patient/C335B6A2-738C-4373-AFF4-DAD1B8B09645"},
            "total": {"value": 1.00},
            "item": [
              {
                "sequence": 1,
                "service": {"text": "OPD01"},
                "quantity": {"value": 10},
                "unitPrice": {"value": 20}
              }
            ]
          }
        }
      ]
    }
    ```
- **Reasons for Use**:
  - **Audit and Tracking**: Retrieve historical claims to verify prior submissions, check statuses, or debug issues (e.g., why a claim was rejected).
  - **Balance Estimation**: If `family_annual_claim` in `ClaimInput` is missing or unreliable, sum `total.value` from prior claims to estimate usage against the annual limit (NPR 100,000 per your JSON rules).
  - **Debugging**: Compare your submitted `ClaimInput` data with IMIS’s stored `Claim` to identify mapping errors.
  - **Workflow Fit**: Useful for post-submission analysis or reporting (e.g., per Chapter 6, Rule 2 of your JSON: monthly claim reporting to HIB).
- **Why It Matters for Your System**: While not critical for claim submission, it helps validate your integration (e.g., ensure claims are recorded correctly) and supports compliance reporting.

#### 4. **Get Claim By Claim UUID**
- **Endpoint**: `GET http://imislegacy.hib.gov.np/api/api_fhir/Claim/{uuid}`
- **Method**: GET
- **Auth**: Same as above
- **Path Parameter**: `uuid` (e.g., `2DDE79F9-AD6D-4821-843D-9396C78BD8FB`)
- **Information Provided**:
  - Returns a single FHIR `Claim` resource for the specified UUID.
  - Same fields as in “Get All Claims” but for one claim.
  - Example response:
    ```json
    {
      "resourceType": "Claim",
      "id": "2DDE79F9-AD6D-4821-843D-9396C78BD8FB",
      "status": "active",
      "patient": {"reference": "Patient/C335B6A2-738C-4373-AFF4-DAD1B8B09645"},
      "total": {"value": 1.00},
      "item": [
        {
          "sequence": 1,
          "service": {"text": "OPD01"},
          "quantity": {"value": 10},
          "unitPrice": {"value": 20}
        }
      ]
    }
    ```
- **Reasons for Use**:
  - **Status Check**: Retrieve the status of a specific claim (e.g., after submission via `POST /Claim/`), useful for tracking adjudication progress.
  - **Debugging Rejections**: If IMIS rejects a claim, fetch it to analyze errors (e.g., invalid `service.text` codes).
  - **Workflow Fit**: Useful for follow-up queries when external systems (e.g., EHR) request updates on a specific `claim_code` (mapped to `Claim.id` or `identifier.value`).
- **Why It Matters for Your System**: Enhances user experience by allowing status checks without resubmitting claims, and supports debugging if your local `ClaimResponse` differs from IMIS’s adjudication.

#### 5. **Submit Claim**
- **Endpoint**: `POST http://imislegacy.hib.gov.np/api/api_fhir/Claim/`
- **Method**: POST
- **Auth**: Same as above
- **Body**: FHIR `Claim` resource (see prior responses for mapping from `ClaimInput`)
- **Information Provided**:
  - Submits a claim and returns a FHIR `ClaimResponse` with adjudication details.
  - Key fields in response:
    - `outcome`: "complete" (approved), "error", etc.
    - `totalBenefit.value`: Approved amount (e.g., NPR 1.00 after caps/deductions).
    - `item[].adjudication`: Per-item approval/rejection with reasons (e.g., "Exceeds ceiling").
    - `error`: Validation errors (e.g., invalid patient UUID).
  - Example response (simplified):
    ```json
    {
      "resourceType": "ClaimResponse",
      "id": "2DDE79F9-AD6D-4821-843D-9396C78BD8FB",
      "outcome": "complete",
      "patient": {"reference": "Patient/C335B6A2-738C-4373-AFF4-DAD1B8B09645"},
      "totalBenefit": {"value": 1.00},
      "item": [
        {
          "sequence": 1,
          "adjudication": [
            {
              "category": {"coding": [{"code": "benefit"}]},
              "amount": {"value": 1.00},
              "reason": {"text": "Approved"}
            }
          ]
        }
      ]
    }
    ```
- **Reasons for Use**:
  - **Core Submission**: This is the primary endpoint for submitting claims to IMIS, aligning with your workflow’s final step.
  - **Adjudication Results**: Provides the final `total_claimable` and per-item approvals, which you return to external systems alongside your local estimate.
  - **Validation Feedback**: Errors in the response (e.g., invalid `service.text` or missing `enterer`) help debug mapping issues from `ClaimInput` to FHIR.
  - **Workflow Fit**: Critical for completing the claim process, as IMIS performs final balance checks (using `remaining_balance` internally) and applies HIB rules (e.g., co-pay, deductibles per your JSON).
- **Why It Matters for Your System**: This endpoint is the culmination of your workflow, ensuring claims are processed and approved by IMIS, with results reflecting official HIB adjudication.

#### 6. **Claim Doc Check Login**
- **Endpoint**: `POST https://claimdoc.hib.gov.np/user/check.php`
- **Method**: POST
- **Auth**: None explicitly in collection (uses `remote-user` header)
- **Body**:
  ```json
  {
    "username": "testuser",
    "password": "f/\\N6k@67"
  }
  ```
- **Information Provided**:
  - Likely returns a session token or authentication confirmation for accessing a separate claim documentation system (`claimdoc.hib.gov.np`).
  - Not a FHIR endpoint; appears to be a legacy or auxiliary system for managing claim-related documents (e.g., attachments).
- **Reasons for Use**:
  - **Attachment Handling**: If your `ClaimInput.attachments` (e.g., discharge summaries) need to be uploaded to a separate HIB system, this endpoint may authenticate access to that system.
  - **Limited Workflow Fit**: Your workflow doesn’t explicitly mention a separate document system, and the FHIR `Claim.supportingInfo` field can handle attachments. This endpoint may be optional unless HIB requires documents to be submitted via `claimdoc.hib.gov.np`.
- **Why It Matters for Your System**: Only relevant if you need to integrate with a secondary HIB system for document uploads. Otherwise, focus on FHIR endpoints.

### Why Each Endpoint Matters for Your Workflow
Your workflow involves:
1. Receiving `ClaimInput` (with `remaining_balance` now included) from external systems.
2. Pre-calculating claimable amounts using JSON rules (HIB guidelines).
3. Submitting to IMIS for final adjudication.
4. Returning results to the caller.

Here’s how the endpoints support this:
- **Patient Info**: Resolves `patient_id` to a UUID, enabling `EligibilityRequest` and `Claim` submissions. Without it, you can’t proceed with IMIS interactions.
- **Eligibility Request**: Provides `remaining_balance` if not supplied in `ClaimInput`, ensuring accurate local calculations (e.g., capping at NPR 50,000 for hospital claims). Reduces IMIS rejections due to balance issues.
- **Get All Claims / Get Claim By UUID**: Supports post-submission tracking and debugging, ensuring your `claim_code` mappings are correct and providing historical data for `family_annual_claim` estimates.
- **Submit Claim**: Core to your workflow, as it submits the claim and returns the final adjudicated amounts, which you combine with your local `ClaimResponse` for the EHR.
- **Claim Doc Check Login**: Optional; only needed if HIB mandates separate document uploads (e.g., for `attachments`).

### Integration Recommendations
- **Use All FHIR Endpoints**: Incorporate `Patient Info`, `Eligibility Request`, and `Submit Claim` into your `ClaimProcessor`. Use `Get All Claims` or `Get Claim By UUID` for status checks or reporting.
- **Handle `remaining_balance`**:
  - If `ClaimInput.remaining_balance` is provided, use it but validate via `EligibilityRequest` to catch outdated values.
  - If `None`, fetch from `EligibilityRequest` using `_get_eligibility` (as shown in prior code).
  - Fallback to `annual_limit - family_annual_claim` (from JSON rules, e.g., NPR 100,000) if IMIS is unavailable.
- **Test with Postman**:
  - Run each endpoint with sample data to confirm response structures.
  - For `EligibilityRequest`, test with a known patient UUID to verify `benefitBalance` fields.
  - For `Submit Claim`, map a sample `ClaimInput` to the FHIR `Claim` payload and check for errors.
- **Handle Errors**:
  - Log 404s (e.g., patient not found) or 400s (e.g., invalid codes) from IMIS.
  - Return clear errors to the EHR (e.g., “Patient ID not found in IMIS”).
- **Security Note**: The collection uses HTTP (not HTTPS), which is insecure for a test server. Confirm with HIB if production uses `https://imis.hib.gov.np/`. Store credentials securely (e.g., environment variables).

### Updated Code Snippet
The prior `ClaimProcessor` code already integrates these endpoints. Key methods:
- `_get_patient_uuid`: Uses `GET /Patient/?identifier` to resolve `patient_id`.
- `_get_eligibility`: Uses `POST /EligibilityRequest/` to fetch `remaining_balance`.
- `submit_to_imis`: Uses `POST /Claim/` with mappings aligned to the Postman example.

To add status checks:
```python
def get_claim_status(self, claim_uuid: str) -> Dict:
    self._authenticate()
    headers = {
        "Authorization": f"Bearer {self.token}",
        "remote-user": self.imis_config.username
    }
    response = requests.get(
        f"{self.imis_config.base_url}Claim/{claim_uuid}",
        headers=headers
    )
    response.raise_for_status()
    return response.json()
```

### Conclusion
The Postman collection’s endpoints fully support your needs:
- **Patient Info**: Resolves patient IDs to UUIDs.
- **Eligibility Request**: Provides `remaining_balance` for accurate pre-calculations.
- **Get All Claims / Get Claim By UUID**: Tracks claim statuses and supports debugging/reporting.
- **Submit Claim**: Submits claims and returns final adjudication.
- **Claim Doc Check Login**: Optional for document uploads.

These endpoints ensure your `ClaimInput` (including `remaining_balance`) maps correctly to IMIS requirements, enhancing your workflow’s reliability. If you share a sample `ClaimInput` JSON, I can demonstrate exact mappings to the `Claim` payload or parse an `EligibilityResponse`!





Yes, your next steps should focus on implementing a robust solution to calculate claimable amounts locally, expose this functionality via an API endpoint, and integrate with the IMIS API using the provided Postman collection to ensure seamless communication. This approach aligns with your workflow: external systems (e.g., EHR) send `ClaimInput` to your API, you pre-calculate claimable amounts using your JSON rules file (HIB guidelines), submit to IMIS for final adjudication, and return results to the caller. Below, I’ll outline a clear plan for these steps, leveraging your existing `ClaimInput` model (with `remaining_balance`) and the Postman collection. I’ll also provide code examples and explain how to make your API communicate with IMIS’s endpoints.

### Step-by-Step Plan
1. **Implement Claim Calculation Logic**:
   - Create functions in your `ClaimProcessor` to calculate claimable amounts for items (e.g., medicines, lab tests) based on your JSON rules file (e.g., caps, co-pays, deductibles).
   - Incorporate `remaining_balance` to cap totals, either from `ClaimInput` or fetched via IMIS’s `EligibilityRequest`.
   - Validate items against HIB guidelines (e.g., formulary checks).

2. **Create API Endpoints**:
   - Expose a `POST /api/insurance/submit_claim` endpoint to receive `ClaimInput`, perform local calculations, submit to IMIS, and return a unified response.
   - Optionally, add a `POST /api/insurance/preview_claim` endpoint for pre-calculations without IMIS submission, useful for EHRs wanting quick estimates.

3. **Integrate with IMIS API**:
   - Use the Postman collection’s endpoints (`Patient`, `EligibilityRequest`, `Claim`) to:
     - Resolve `patient_id` to UUIDs.
     - Fetch `remaining_balance` if not provided.
     - Submit claims and parse `ClaimResponse`.
   - Handle authentication (basic auth + `remote-user` header) and errors (e.g., 400 for invalid codes).

4. **Test and Validate**:
   - Use the Postman collection to test IMIS interactions with sample `ClaimInput` data.
   - Ensure your local calculations align with IMIS adjudication to minimize discrepancies.

### Step 1: Implement Claim Calculation Logic
You already have a JSON rules file (from earlier) and a `ClaimProcessor` skeleton. Update it to handle item calculations and incorporate `remaining_balance`. Here’s a refined version:

#### JSON Rules (Assumed Structure)
```json
{
  "medicine_rules": [
    {"category": "OPD Medicines", "max_amount": 1000, "validation": "HIB drug formulary अनुसार मात्र claimable"},
    {"category": "IPD Medicines", "max_amount": 50000, "validation": "Standard Treatment Protocol अनुसार"},
    {"category": "Generic Medicines", "discount": 10, "validation": "Generic name अनुसार claim"}
  ],
  "lab_rules": [
    {"category": "Lab Tests", "max_amount": 2000, "validation": "HIB approved tests"}
  ],
  "claim_limits": {
    "annual": 100000,
    "co_payment": 10,
    "deductible": 500
  }
}
```

#### Updated `ClaimProcessor`
```python
import json
import requests
from typing import Dict, Optional, List
from pydantic import BaseModel, Field
from fastapi import HTTPException
import logging
from enum import Enum
from datetime import date
import uuid

# Models (from your prior input, with enums for clarity)
class PatientCategory(str, Enum):
    GENERAL = "general"
    SENIOR = "senior"

class HospitalType(str, Enum):
    PHC = "phc"
    GOVERNMENT = "government"
    PRIVATE = "private"

class Item(BaseModel):
    type: str  # e.g., 'medicine', 'lab_test'
    code: str
    name: str
    quantity: float
    billed_amount: float
    category: str  # e.g., 'OPD Medicines'

class Diagnosis(BaseModel):
    code: str  # e.g., ICD-10 code
    description: Optional[str]

class ClaimInput(BaseModel):
    patient_id: str
    patient_age: int
    category: PatientCategory
    family_annual_claim: float
    remaining_balance: Optional[float]
    visit_date: date
    service_type: str  # 'OPD', 'ER', 'IPD'
    opd_code: Optional[str]
    claim_code: str = Field(default_factory=lambda: str(uuid.uuid4()))
    doctor_nmc: Optional[str]
    signature_reason: Optional[str]
    discharge_status: Optional[bool]
    discharge_summary: Optional[str]
    diagnosis: Diagnosis
    items: List[Item]
    total_billed: float
    hospital_type: HospitalType
    attachments: Optional[List[str]]
    health_record: Optional[dict]

class ClaimableItem(BaseModel):
    original_item: Item
    claimable_amount: float
    reason: str
    applied_rules: List[str]

class ClaimResponse(BaseModel):
    claim_code: str
    total_billed: float
    total_claimable: float
    deductible_applied: float
    co_payment: float
    remaining_after_claim: float
    items: List[ClaimableItem]
    validation_errors: List[str]
    is_submittable: bool

class IMISConfig(BaseModel):
    base_url: str = "http://imislegacy.hib.gov.np/api/api_fhir/"
    username: str = "hib_testuser_testfhir"
    password: str = "f/\\N6k@67"

class ClaimProcessor:
    def __init__(self, rules_path: str = 'rules/hib_rules.json', imis_config: IMISConfig = None):
        with open(rules_path, 'r') as f:
            self.rules = json.load(f)
        self.imis_config = imis_config or IMISConfig()
        self.token = None
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

    def _authenticate(self) -> None:
        if not self.token:
            headers = {"remote-user": self.imis_config.username}
            response = requests.post(
                f"{self.imis_config.base_url}../login",
                json={"username": self.imis_config.username, "password": self.imis_config.password},
                headers=headers
            )
            response.raise_for_status()
            self.token = response.json().get("token")  # Adjust based on actual response

    def _get_patient_uuid(self, patient_id: str) -> str:
        self._authenticate()
        headers = {
            "Authorization": f"Bearer {self.token}",
            "remote-user": self.imis_config.username
        }
        response = requests.get(
            f"{self.imis_config.base_url}Patient/?identifier={patient_id}",
            headers=headers
        )
        response.raise_for_status()
        data = response.json()
        entries = data.get("entry", [])
        if not entries:
            raise HTTPException(404, detail=f"Patient {patient_id} not found in IMIS")
        return entries[0]["resource"]["id"]

    def _get_eligibility(self, patient_uuid: str, service_type: str) -> Optional[float]:
        self._authenticate()
        payload = {
            "resourceType": "EligibilityRequest",
            "patient": {"reference": f"Patient/{patient_uuid}"}
        }
        headers = {
            "Authorization": f"Bearer {self.token}",
            "remote-user": self.imis_config.username,
            "Content-Type": "application/json"
        }
        response = requests.post(
            f"{self.imis_config.base_url}EligibilityRequest/",
            json=payload,
            headers=headers
        )
        if response.status_code != 200:
            self.logger.warning(f"Eligibility check failed for {patient_uuid}: {response.text}")
            return None
        data = response.json()
        category_map = {"OPD": "non-hospital", "IPD": "hospital", "ER": "non-hospital"}
        target_category = category_map.get(service_type, "hospital")
        for insurance in data.get("insurance", []):
            for benefit in insurance.get("benefitBalance", []):
                category = benefit.get("category", {}).get("coding", [{}])[0].get("code", "")
                if category == target_category:
                    return benefit.get("allowedMoney", {}).get("value", None)
        return None

    def calculate_claim(self, input: ClaimInput) -> ClaimResponse:
        total_billed = input.total_billed
        total_claimable = 0.0
        deductible = self.rules['claim_limits']['deductible']  # NPR 500
        co_payment_pct = self.rules['claim_limits']['co_payment'] / 100  # 10%
        annual_limit = self.rules['claim_limits']['annual']  # NPR 100,000
        remaining = input.remaining_balance
        errors = []

        # Fetch balance from IMIS if not provided
        if remaining is None:
            try:
                patient_uuid = self._get_patient_uuid(input.patient_id)
                remaining = self._get_eligibility(patient_uuid, input.service_type)
                if remaining is None:
                    remaining = annual_limit - input.family_annual_claim
                    errors.append("IMIS eligibility unavailable; using fallback balance")
            except Exception as e:
                self.logger.warning(f"Failed to fetch eligibility: {e}")
                remaining = annual_limit - input.family_annual_claim
                errors.append("Could not fetch IMIS balance; using fallback")

        claimable_items = []
        for item in input.items:
            rule = self._find_matching_rule(item)
            if not rule:
                errors.append(f"No rule for item {item.name}")
                claimable_items.append(ClaimableItem(original_item=item, claimable_amount=0.0, reason='Invalid: No matching rule', applied_rules=[]))
                continue

            if not self._is_valid_per_rule(item, rule):
                errors.append(f"Item {item.name} fails validation: {rule.get('validation')}")
                claimable_items.append(ClaimableItem(original_item=item, claimable_amount=0.0, reason='Invalid', applied_rules=[rule['category']]))
                continue

            max_amt = rule.get('max_amount', float('inf'))
            item_claimable = min(item.billed_amount * item.quantity, max_amt)
            discount = rule.get('discount', 0) / 100
            item_claimable *= (1 - discount)

            total_claimable += item_claimable
            claimable_items.append(ClaimableItem(original_item=item, claimable_amount=item_claimable, reason='Approved', applied_rules=[rule['category']]))

        deductible_applied = min(deductible, total_claimable)
        total_claimable -= deductible_applied
        co_payment = total_claimable * co_payment_pct
        total_claimable -= co_payment

        if total_claimable > remaining:
            total_claimable = remaining
            errors.append("Claim exceeds remaining balance; capped")

        remaining_after = remaining - total_claimable

        return ClaimResponse(
            claim_code=input.claim_code,
            total_billed=total_billed,
            total_claimable=total_claimable,
            deductible_applied=deductible_applied,
            co_payment=co_payment,
            remaining_after_claim=remaining_after,
            items=claimable_items,
            validation_errors=errors,
            is_submittable=len(errors) == 0
        )

    def _find_matching_rule(self, item: Item) -> Dict:
        for r in self.rules.get('medicine_rules', []) + self.rules.get('lab_rules', []):
            if r['category'] == item.category:
                return r
        return None

    def _is_valid_per_rule(self, item: Item, rule: Dict) -> bool:
        # Placeholder: Implement formulary check (e.g., query IMIS CodeSystem or JSON list)
        return True
```

**Key Features**:
- Calculates per-item claimable amounts using JSON rules (e.g., NPR 1,000 cap for OPD medicines).
- Applies deductible (NPR 500) and co-payment (10%).
- Caps `total_claimable` at `remaining_balance` (from `ClaimInput` or IMIS).
- Logs validation errors (e.g., non-formulary items).

### Step 2: Create API Endpoints
Expose the calculation and submission logic via FastAPI endpoints. Include a preview endpoint for flexibility.

```python
from fastapi import FastAPI, Body, HTTPException

app = FastAPI()
processor = ClaimProcessor()

@app.post("/api/insurance/preview_claim")
async def preview_claim(input: ClaimInput = Body(...)):
    try:
        return processor.calculate_claim(input)
    except Exception as e:
        processor.logger.error(f"Preview error: {e}")
        raise HTTPException(500, detail=str(e))

@app.post("/api/insurance/submit_claim")
async def submit_claim(input: ClaimInput = Body(...)):
    try:
        local_response = processor.calculate_claim(input)
        if not local_response.is_submittable:
            raise HTTPException(400, detail={"errors": local_response.validation_errors})

        imis_response = processor.submit_to_imis(input, local_response)
        return {
            "claim_code": input.claim_code,
            "local_estimate": local_response.dict(),
            "imis_response": imis_response
        }
    except requests.RequestException as e:
        processor.logger.error(f"IMIS error: {e}")
        raise HTTPException(502, detail=str(e))
    except Exception as e:
        processor.logger.error(f"Error: {e}")
        raise HTTPException(500, detail=str(e))
```

**Endpoints**:
- `/preview_claim`: Returns local `ClaimResponse` (claimable amounts, errors) without IMIS submission.
- `/submit_claim`: Runs local calculation, submits to IMIS, and returns both local and IMIS responses.

### Step 3: Integrate with IMIS API
Add the `submit_to_imis` method to `ClaimProcessor`, using the Postman collection’s `Claim` endpoint structure.

```python
def submit_to_imis(self, input: ClaimInput, local_response: ClaimResponse) -> Dict:
    patient_uuid = self._get_patient_uuid(input.patient_id)
    # Hardcode for testing; query IMIS for production
    facility_uuid = "1ac457d3-efd3-4a67-89b3-bf8cbe18045d"
    doctor_uuid = "7aa79c53-057e-4e77-8576-dfcfb03584a8"

    fhir_claim = {
        "resourceType": "Claim",
        "billablePeriod": {
            "start": input.visit_date.isoformat(),
            "end": input.visit_date.isoformat()
        },
        "created": input.visit_date.isoformat(),
        "diagnosis": [
            {
                "sequence": 1,
                "type": [{"text": input.diagnosis.code}]  # Adjust for ICD-10 if needed
            }
        ],
        "enterer": {"reference": f"Practitioner/{doctor_uuid}"},
        "facility": {"reference": f"Location/{facility_uuid}"},
        "identifier": [
            {
                "type": {
                    "coding": [
                        {"code": "MR", "system": "https://hl7.org/fhir/valueset-identifier-type.html"}
                    ]
                },
                "use": "usual",
                "value": input.claim_code
            }
        ],
        "item": [
            {
                "sequence": idx + 1,
                "category": {"text": item.type},
                "quantity": {"value": item.quantity},
                "service": {"text": item.code},
                "unitPrice": {"value": item.billed_amount}
            } for idx, item in enumerate(input.items)
        ],
        "total": {"value": input.total_billed},
        "patient": {"reference": f"Patient/{patient_uuid}"},
        "careType": input.service_type[0],  # OPD→"O", IPD→"I", ER→"E"
        "type": {"text": input.service_type[0]}
    }

    headers = {
        "Authorization": f"Bearer {self.token}",
        "remote-user": self.imis_config.username,
        "Content-Type": "application/json"
    }
    response = requests.post(
        f"{self.imis_config.base_url}Claim/",
        json=fhir_claim,
        headers=headers
    )
    response.raise_for_status()
    return response.json()
```

**Integration Details**:
- **Patient UUID**: Use `GET /Patient/?identifier={patient_id}` to resolve `patient_id`.
- **Eligibility**: Use `POST /EligibilityRequest/` to fetch `remaining_balance` if not provided.
- **Claim Submission**: Map `ClaimInput` to FHIR `Claim` as shown, aligning with the Postman example.
- **Error Handling**: Catch 400/404 errors from IMIS and return actionable messages (e.g., “Invalid service code OPD01”).

### Step 4: Test and Validate
- **Postman Testing**:
  - Import the collection into Postman.
  - Test `GET /Patient/?identifier=740500036` to get a UUID.
  - Test `POST /EligibilityRequest/` with the UUID to confirm `remaining_balance`.
  - Test `POST /Claim/` with a mapped `ClaimInput` to verify submission.
- **Local Testing**: Use a sample `ClaimInput`:
  ```json:disable-run
  {
    "patient_id": "740500036",
    "patient_age": 30,
    "category": "general",
    "family_annual_claim": 20000.0,
    "remaining_balance": 80000.0,
    "visit_date": "2025-01-29",
    "service_type": "OPD",
    "diagnosis": {"code": "J45", "description": "Asthma"},
    "items": [
      {"type": "medicine", "code": "MED001", "name": "Paracetamol", "quantity": 10.0, "billed_amount": 100.0, "category": "OPD Medicines"},
      {"type": "lab_test", "code": "LAB001", "name": "Blood Test", "quantity": 1.0, "billed_amount": 1500.0, "category": "Lab Tests"}
    ],
    "total_billed": 2500.0,
    "hospital_type": "private"
  }
  ```
- **Expected Output** (from `/submit_claim`):
  ```json
  {
    "claim_code": "uuid-string",
    "local_estimate": {
      "total_billed": 2500.0,
      "total_claimable": 1800.0,  // After NPR 500 deductible, 10% co-pay, capped at rules
      "deductible_applied": 500.0,
      "co_payment": 200.0,
      "remaining_after_claim": 78200.0,
      "items": [
        {"original_item": {...}, "claimable_amount": 1000.0, "reason": "Approved", "applied_rules": ["OPD Medicines"]},
        {"original_item": {...}, "claimable_amount": 1000.0, "reason": "Capped at max", "applied_rules": ["Lab Tests"]}
      ],
      "validation_errors": [],
      "is_submittable": true
    },
    "imis_response": {
      "resourceType": "ClaimResponse",
      "totalBenefit": {"value": 1800.0},
      "item": [
        {"sequence": 1, "adjudication": [{"amount": {"value": 1000.0}, "reason": {"text": "Approved"}}]},
        {"sequence": 2, "adjudication": [{"amount": {"value": 1000.0}, "reason": {"text": "Approved"}}]}
      ],
      "outcome": "complete"
    }
  }
  ```

### Why This Approach Works
- **Calculation**: `calculate_claim` ensures accurate pre-calculations using JSON rules, capped by `remaining_balance`.
- **API**: Endpoints provide flexibility (preview vs. submit) and clear responses for EHRs.
- **IMIS Integration**: Leverages Postman endpoints to resolve UUIDs, fetch balances, and submit claims, ensuring compatibility.
- **Maintainability**: JSON rules allow updates without code changes, and IMIS handles final adjudication.

### Next Steps
1. **Implement and Test Locally**:
   - Deploy the above code in your FastAPI project.
   - Test `/preview_claim` with sample inputs to verify calculations.
2. **Test IMIS Integration**:
   - Use Postman to confirm endpoint behavior (e.g., `EligibilityRequest` response structure).
   - Test `/submit_claim` with the sample input against the test server.
3. **Handle Edge Cases**:
   - Add retries for IMIS network failures (e.g., using `tenacity` library).
   - Validate item codes against a formulary list in `_is_valid_per_rule`.
4. **Secure Credentials**: Store `IMISConfig` in environment variables, not code.
5. **Document for EHRs**: Provide an OpenAPI spec (FastAPI auto-generates) with sample inputs/outputs.

If you share a specific `ClaimInput` or need help with formulary validation, I can refine the code further!
```